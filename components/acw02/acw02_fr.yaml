# esphome:
#   on_boot:
#     then:
#       - lambda: |-
#           id(ac_ctrl).set_temp_number(id(temp_set));

# esphome:
#   on_boot:
#     then:
#       - lambda: |-
#           id(ac_ctrl).set_ambient_temperature_sensor_c(id(ac_ambient_temperature_c));
#           id(ac_ctrl).set_ambient_temperature_sensor_f(id(ac_ambient_temperature_f));


text:
  - platform: template
    name: "MQTT: Broker"
    id: mqtt_broker_address_input
    entity_category: config
    mode: text
    lambda: |-
      return id(ac_ctrl).get_mqtt_broker();
    set_action:
      then:
        - lambda: |-
            id(ac_ctrl).set_mqtt_broker(x);
    update_interval: 1s

  - platform: template
    name: "MQTT: Login"
    id: mqtt_login_input
    entity_category: config
    mode: text
    lambda: |-
      return id(ac_ctrl).get_mqtt_username();
    set_action:
      then:
        - lambda: |-
            id(ac_ctrl).set_mqtt_username(x);
    update_interval: 1s

  - platform: template
    name: "MQTT: Password"
    id: mqtt_password_input
    entity_category: config
    mode: password
    lambda: |-
      return id(ac_ctrl).get_mqtt_password();
    set_action:
      then:
        - lambda: |-
            id(ac_ctrl).set_mqtt_password(x);
    update_interval: 1s

  - platform: template
    name: "MQTT: Port"
    id: mqtt_port_input
    mode: text
    entity_category: config
    lambda: |-
      return id(ac_ctrl).int_to_string(id(ac_ctrl).get_mqtt_port());
    set_action:
      then:
        - lambda: |-
            id(ac_ctrl).set_mqtt_port_from_string(x);
    update_interval: 1s

switch:
  - platform: template
    name: "G1: Commande silencieuse"
    id: mute_commande_api
    icon: mdi:volume-off
    entity_category: "config"
    lambda: |-
      return id(ac_ctrl).is_mute_on();
    turn_on_action:
      - lambda: id(ac_ctrl).set_mute(true);
    turn_off_action:
      - lambda: id(ac_ctrl).set_mute(false);

  - platform: template
    name: "Z-Config: Exclu mode Auto"
    id: disable_mode_auto
    icon: "mdi:thermostat-cog"
    entity_category: "config"
    lambda: |-
      return id(ac_ctrl).is_disable_mode_auto();
    turn_on_action:
      - lambda: id(ac_ctrl).set_disable_mode_auto(true);
    turn_off_action:
      - lambda: id(ac_ctrl).set_disable_mode_auto(false);

  - platform: template
    name: "Z-Config: Exclu mode Chauffage"
    id: disable_mode_heat
    icon: "mdi:thermostat-cog"
    entity_category: "config"
    lambda: |-
      return id(ac_ctrl).is_disable_mode_heat();
    turn_on_action:
      - lambda: id(ac_ctrl).set_disable_mode_heat(true);
    turn_off_action:
      - lambda: id(ac_ctrl).set_disable_mode_heat(false);

  - platform: template
    name: "Z-Config: Exclu mode Climatisation"
    id: disable_mode_cool
    icon: "mdi:thermostat-cog"
    entity_category: "config"
    lambda: |-
      return id(ac_ctrl).is_disable_mode_cool();
    turn_on_action:
      - lambda: id(ac_ctrl).set_disable_mode_cool(true);
    turn_off_action:
      - lambda: id(ac_ctrl).set_disable_mode_cool(false);

  - platform: template
    name: "Z-Config: Exclu mode Déshumidification"
    id: disable_mode_dry
    icon: "mdi:thermostat-cog"
    entity_category: "config"
    lambda: |-
      return id(ac_ctrl).is_disable_mode_dry();
    turn_on_action:
      - lambda: id(ac_ctrl).set_disable_mode_dry(true);
    turn_off_action:
      - lambda: id(ac_ctrl).set_disable_mode_dry(false);

  - platform: template
    name: "Z-Config: Exclu mode Ventilation"
    id: disable_mode_fan
    icon: "mdi:thermostat-cog"
    entity_category: "config"
    lambda: |-
      return id(ac_ctrl).is_disable_mode_fan();
    turn_on_action:
      - lambda: id(ac_ctrl).set_disable_mode_fan(true);
    turn_off_action:
      - lambda: id(ac_ctrl).set_disable_mode_fan(false);

  - platform: template
    name: "G1: auto calc climate (eco/auto)"
    id: option_recalculate_climate
    icon: mdi:autorenew
    entity_category: "config"
    lambda: |-
      return id(ac_ctrl).is_option_recalculate_climate();
    turn_on_action:
      - lambda: id(ac_ctrl).set_option_recalculate_climate(true);
    turn_off_action:
      - lambda: id(ac_ctrl).set_option_recalculate_climate(false);

button:
  - platform: restart
    name: "G1: Redémarrer"
    id: restart_module_ac

  - platform: restart
    name: "MQTT: valider"
    id: validate_mqtt
  
  - platform: template
    name: "G1: Actualiser data"
    id: get_status_button
    icon: mdi:cloud-refresh-variant
    entity_category: "config"
    on_press:
      - lambda: |-
          id(ac_ctrl).reload_ac_info();

  - platform: template
    name: "G1: Reconstruire les entitées MQTT"
    id: rebuild_mqtt_entities
    icon: mdi:cloud-refresh-variant
    entity_category: "config"
    on_press:
      - lambda: |-
          id(ac_ctrl).rebuild_mqtt_entity();
  
  - platform: template
    name: "Z-Config: Valider"
    id: apply_disable_settings
    icon: mdi:send
    entity_category: "config"
    on_press:
      - lambda: |-
          id(ac_ctrl).apply_disable_settings();


# le mode chaud et auto et mettre une option pour les desactiver + entité commenté coté ha
# desactiver le changement de temp et de vitesse de fan en mode eco
# desactiver le changement de temp en mode auto
# actuellement je bloque le setter pour le temp C ou F en fonction du mode, faudrait reset la valeur ca la ca reste bloquer
# bien verifier les setter l'histoire de les faire si la variable est vraiment modif, pour eviter les envoi au start
# apres avoir gerer le rx, implementer les trame inconnu et periodique voir les trame via interval rx envoyer et essayer de match avec les tx

# dans les setter bien verif que le status est diff (protection)


# MQTT
# faire un ping pour mettre available, detecter quand desactiver climate mqtt, indispo car reboot, ou indispo car ne reponds plus 
# declencher l'init mqtt du setup apres mqtt connect
# utilisez des variaible global pour set ip username password de mqtt
# option switch pour desactiver chacun des mode
# option pour definir mode par defaut
# gerer la perte de connexion et que faire avec le suscribe ? 
# faire un sensor quand c'est indispo, et faire un sensor quand ya une erreur
# si des mode sont desactiver, forcer le mode si par defaut si un mode desactivé est activé
# mode renommé les option du select mode mais juste pour lui
# faire un sensor qui indique les commande ignoré et pourquoi, par exemple le changement de vitesse de ventilation en mode eco
# dans le cas ou par exemple le mode eco voir pour eliminer les option dans climate et le reconstruire .... voir si c'est pas trop gourmand
# faire un sensor pour chaque availability et en cas d'erreur
# revoir le mode clean, enlever le mecanisme qui fait auto un off et declenche le clean, par disable le bouton si power, et enable si off, et si off faire la commande off + clean sans delay